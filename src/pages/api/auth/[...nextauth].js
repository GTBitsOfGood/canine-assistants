import { MongoDBAdapter } from "@next-auth/mongodb-adapter";
import NextAuth from "next-auth";
import dbConnect, {
  DB_CONNECTION_STRING,
} from "../../../../server/db/dbConnect";
import GoogleProvider from "next-auth/providers/google";

let cachedPromise;

import { MongoClient, ObjectId } from "mongodb";
import User from "../../../../server/db/models/User";

import CredentialsProvider from "next-auth/providers/credentials";
import { verifyUser, signup } from "../../../../server/db/actions/User";
// import Account from "../../../../server/db/models/Account";

const client = new MongoClient(DB_CONNECTION_STRING);

const retrievePromise = () => {
  if (cachedPromise) {
    return cachedPromise;
  } else {
    cachedPromise = client.connect();
    return cachedPromise;
  }
};

/**
 * @type {import("next-auth").NextAuthOptions}
 */
export const authOptions = {
  adapter: MongoDBAdapter(retrievePromise()),

  // Use JWTs for everything session-related
  session: {
    strategy: "jwt",
  },
  secret: process.env.NEXTAUTH_SECRET,
  providers: [
    CredentialsProvider({
      id: "credentials",
      name: "Login with Username and Password",

      async authorize(credentials) {
        const response = await verifyUser(
          credentials.email,
          credentials.password,
        );

        if (response.status === 200) {
          return {
            id: response.message._id,
            ...response.message,
          };
        } else {
          throw new Error(response.message);
        }
      },
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Password", type: "password" },
      },
    }),
    CredentialsProvider({
      id: "signup",
      name: "Signup with Email and Password",

      async authorize(credentials) {
        const response = await signup(
          credentials.email,
          credentials.password,
          credentials.name,
        );

        if (response.status === 200) {
          return {
            id: response.message._id,
            ...response.message,
          };
        } else {
          throw new Error(response.message);
        }
      },
      credentials: {
        email: { label: "Email", type: "text" },
        password: { label: "Password", type: "password" },
        name: { label: "Name", type: "text" },
      },
    }),
    GoogleProvider({
      id: "google",
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    }),
  ],
  pages: {
    signIn: "/login",
    // newUser: "/signup",
    // error: "/login",
  },
  events: {
    //   updateUser: async (message) => {
    //     // await dbConnect();
    //     const response = await createUser(message);

    //     const _id = new ObjectId(message.user.id);

    //     // TODO: Find a way of avoiding unnecessary deletion calls
    //     await User.deleteOne({ _id });

    //     const newUserRecord = {
    //       _id,
    //       name: message.user.name,
    //       email: message.user.email,
    //       image: message.user.image,
    //       role: "User", // TODO: Default string shouldn't be hardcoded and instead moved somewhere else
    //     };

    //     const user = new User(newUserRecord);

    //     await user.save();
    //   },
    createUser: async (message) => {
      console.log("HERE1");
      // TODO: Problem: Google won't link a user to an account if the user is already in the database
      // await dbConnect();
      // // await User.deleteOne({ _id }); // delete the user automatically generated by next-auth
      // const invitedUser = await User.findOne({ email: message.user.email, _id: { $not: { $eq: message.user.id } } });
      // await User.updateOne({ _id: message.user.id }, { acceptedInvite: true, isActive: true, role: invitedUser.role });
      // await User.deleteOne({ _id: invitedUser._id }); // delete the previously invited user
    },
  },
  callbacks: {
    async signIn({ user, account }) {
      // console.log("Here2", user, account)
      const email = user.email
        ? user.email.toLowerCase()
        : user._doc.email.toLowerCase();
      const invitedUser = await User.findOne({ email });
      // TODO: let any user sign in with google
      if (
        account.providerId != "google" &&
        (!invitedUser || !invitedUser.isActive)
      ) {
        return false;
      }
      // if (!account.userId) {
      //   console.log("here3")
      //   account.userId = invitedUser._id;
      //   try {
      //     const linkAccount = new Account({ ...account })
      //     console.log(account)
      //     await linkAccount.save();
      //   } catch (e) {
      //     console.log(e)
      //   }
      // }

      return true;
    },
    async jwt({ token }) {
      const user = await User.findById(token.sub);
      if (user) {
        token.name = user.name;
        token.email = user.email;
        token.image = user.image;
        token.role = user.role;
        token.id = user._id;
      }
      return token;
    },

    session: async ({ session, token }) => {
      if (token) {
        session.user.role = token.role;
        session.user._id = token.sub;
      }

      return session;
    },
  },
};

export default NextAuth(authOptions);
